Documentación básica para SaaS MarketFlex.



---


# Sección 1: Concepto


## Nombre Sugerido
**MarketFlex**


**Razón**: El nombre fusiona "Market" (mercado) y "Flex" (flexibilidad), reflejando la capacidad del boilerplate para adaptarse a diversos nichos de marketplace, como automotriz, inmobiliario o servicios, sin necesidad de grandes modificaciones. Transmite versatilidad, modernidad y escalabilidad.


## Descripción Básica del Concepto
MarketFlex es un boilerplate de Software as a Service (SaaS) diseñado para facilitar a emprendedores, desarrolladores y empresas el lanzamiento de marketplaces personalizados y escalables. 

Entre sus funcionalidades principales se incluyen:


- **Listado y búsqueda avanzada**: Soporte para productos o servicios con filtros dinámicos y campos personalizables según el nicho.
- **Carrito de compras y checkout seguro**: Integración nativa con MercadoPago para procesar pagos mediante tarjetas, transferencias y efectivo.
- **Mensajería interna**: Comunicación directa entre compradores y vendedores para negociaciones y seguimiento.
- **Suscripciones para vendedores**: Planes gestionados con pagos recurrentes a través de MercadoPago.
- **Panel de administración**: Gestión centralizada de usuarios, listings, transacciones y configuraciones del marketplace.
- **Cumplimiento legal**: Soporte preconfigurado para regulaciones de privacidad (GDPR, leyes locales) y banner de cookies editable.


La plataforma ofrece una interfaz moderna, responsiva y fácil de usar, compatible con dispositivos móviles y de escritorio. Su diseño reduce el tiempo de desarrollo, permitiendo a los usuarios centrarse en personalizar el marketplace según sus necesidades específicas.


## Propuesta de Valor Única
MarketFlex se destaca por las siguientes características diferenciales:


- **Adaptabilidad sin código**: Configuración de listings y filtros mediante un sistema de campos dinámicos, eliminando la necesidad de alterar el código base para cada nicho.
- **Integración completa con MercadoPago**: Soporte para pagos únicos, suscripciones y diversos métodos de pago, optimizado para mercados latinoamericanos.
- **Modelo de ingresos versátil**: Configuración de comisiones por transacción, suscripciones para vendedores o espacios publicitarios desde el panel de administración.
- **Cumplimiento legal incorporado**: Documentos editables y soporte para regulaciones de privacidad en múltiples regiones (Argentina, México, Colombia, GDPR).


Estas ventajas permiten lanzar un marketplace profesional rápidamente, con bases técnicas y legales sólidas, ahorrando tiempo y recursos.


## Público Objetivo
MarketFlex está dirigido a:


- **Emprendedores y startups**: Quienes buscan lanzar marketplaces en nichos específicos (automotriz, inmobiliario, servicios) con mínima configuración.
- **Desarrolladores full-stack**: Profesionales que necesitan un boilerplate robusto y adaptable para proyectos de clientes o MVPs.
- **Empresas establecidas**: Organizaciones que desean expandir su oferta hacia un modelo de marketplace, aprovechando la escalabilidad de la plataforma.


## Ejemplo de Uso
Supongamos que un emprendedor desea lanzar un marketplace de autos usados en Argentina:


1. **Configuración inicial**: Clona el repositorio, ajusta las variables de entorno (Supabase, MercadoPago) y despliega en Vercel.
2. **Personalización**: Desde el panel de administración, define campos como "marca", "modelo", "año" y "kilometraje" para los listings.
3. **Pagos**: Habilita métodos locales (transferencias, efectivo) y establece comisiones por transacción.
4. **Lanzamiento**: Publica el marketplace con un dominio personalizado y un tema visual adaptado.


Posteriormente, el mismo emprendedor decide lanzar un marketplace inmobiliario en México:


- **Reutilización**: Ajusta los campos a "tipo de propiedad", "ubicación" y "metros cuadrados".
- **Adaptación**: Cambia la moneda a MXN y habilita pagos en USD para compradores internacionales.
- **Legalidad**: Actualiza los documentos legales para cumplir con las leyes mexicanas.


Todo esto se realiza sin modificar el código base, solo ajustando configuraciones.


## Cómo Funcionará para los Usuarios
MarketFlex ofrece una experiencia intuitiva y flexible para todos los involucrados:


- **Administradores**: Configuran el nicho, métodos de pago, modelos de ingresos y documentos legales desde un panel centralizado.
- **Vendedores**: Publican listings con campos personalizados, gestionan suscripciones y responden a consultas de compradores.
- **Compradores**: Navegan listings con filtros avanzados, añaden productos al carrito o contactan a vendedores, y completan pagos seguros.
- **Todos los usuarios**: Disfrutan de una interfaz moderna con temas personalizables (claro, oscuro, pastel, retro) y soporte multilingüe.


## Tecnologías Iniciales a Usar
- **Next.js**: Framework para el frontend y backend.
- **Supabase**: Autenticación, base de datos (PostgreSQL), almacenamiento y funcionalidad en tiempo real.
- **MercadoPago SDK**: Procesamiento de pagos únicos y suscripciones.
- **Shadcn**: Componentes UI modernos y accesibles.
- **TypeScript**: Código robusto con tipado seguro.
- **Resend**: Envío de correos para autenticación y notificaciones.
- **next-themes**: Soporte para múltiples temas visuales.
- **next-intl**: Internacionalización para múltiples idiomas.
- **react-cookie-consent**: Banner de consentimiento de cookies.


---




---


# Sección 2: Modelo de Datos Detallado


## Introducción
El modelo de datos de **MarketFlex** es la base técnica que soporta las funcionalidades del marketplace. Está diseñado para ser flexible, escalable y adaptable a diversos nichos, permitiendo gestionar usuarios, listings dinámicos, transacciones, suscripciones y configuraciones de manera eficiente. Este documento detalla las tablas principales, sus campos, las relaciones entre ellas y las consideraciones de rendimiento y seguridad.


## Objetivos
- Definir entidades y relaciones que soporten múltiples nichos sin necesidad de modificar el esquema de la base de datos.
- Garantizar escalabilidad para manejar miles de usuarios y listings concurrentes.
- Facilitar la personalización mediante campos dinámicos.
- Asegurar la seguridad y el cumplimiento legal mediante políticas de acceso.


## Entidades Principales


### 1. `users`
**Descripción**: Almacena la información de todos los usuarios, incluyendo compradores, vendedores y administradores.


**Campos**:
- `id`: UUID (clave primaria).
- `email`: String (único, requerido).
- `username`: String (único, requerido).
- `password`: String (hash, requerido).
- `role`: String ("buyer" | "seller" | "admin").
- `bio`: Text (opcional).
- `avatar_url`: String (opcional).
- `subscription_id`: UUID (clave foránea a `subscriptions.id`, opcional).
- `created_at`: Timestamp.
- `updated_at`: Timestamp.


**Índices**:
- `email`: Único.
- `username`: Único.
- `role`: Para consultas por rol.


---


### 2. `listings`
**Descripción**: Representa los productos o servicios publicados en el marketplace, con soporte para campos personalizados.


**Campos**:
- `id`: UUID (clave primaria).
- `title`: String (requerido).
- `description`: Text (requerido).
- `price`: Decimal (requerido).
- `currency`: String (ej. "ARS", "MXN", "USD").
- `author_id`: UUID (clave foránea a `users.id`).
- `category`: String (ej. "autos", "inmobiliario").
- `custom_fields`: JSONB (campos personalizados según el nicho, ej. {"marca": "Toyota", "año": 2020}).
- `status`: String ("active" | "sold" | "pending").
- `created_at`: Timestamp.
- `updated_at`: Timestamp.


**Índices**:
- `author_id`: Para consultas por vendedor.
- `category`: Para filtrar por nicho.
- `price`: Para ordenar por precio.
- `status`: Para listar solo listings activos.


---


### 3. `listing_configurations`
**Descripción**: Define los campos personalizados disponibles para cada categoría de listing.


**Campos**:
- `id`: UUID (clave primaria).
- `category`: String (ej. "autos", "inmobiliario").
- `fields`: JSONB (definición de campos, ej. {"marca": "string", "año": "number"}).
- `required_fields`: Array<String> (campos obligatorios, ej. ["marca", "precio"]).


**Índices**:
- `category`: Único.


---


### 4. `transactions`
**Descripción**: Registra las compras directas o contactos entre usuarios relacionados con un listing.


**Campos**:
- `id`: UUID (clave primaria).
- `listing_id`: UUID (clave foránea a `listings.id`).
- `buyer_id`: UUID (clave foránea a `users.id`).
- `type`: String ("purchase" | "contact").
- `amount`: Decimal (solo para "purchase").
- `currency`: String (solo para "purchase").
- `status`: String ("pending" | "completed" | "failed").
- `mercado_pago_id`: String (ID de la transacción en MercadoPago).
- `created_at`: Timestamp.


**Índices**:
- `listing_id`: Para agrupar transacciones por listing.
- `buyer_id`: Para historial de compras.
- `status`: Para filtrar transacciones pendientes.


---


### 5. `subscriptions`
**Descripción**: Gestiona los planes de suscripción disponibles para los vendedores.


**Campos**:
- `id`: UUID (clave primaria).
- `plan_name`: String (ej. "basic", "premium").
- `price`: Decimal.
- `currency`: String.
- `features`: JSONB (beneficios del plan, ej. {"listings_max": 10, "priority_support": true}).
- `mercado_pago_plan_id`: String (ID del plan en MercadoPago).
- `created_at`: Timestamp.


**Índices**:
- `plan_name`: Para consultas por plan.


---


### 6. `messages`
**Descripción**: Almacena las conversaciones entre usuarios del marketplace.


**Campos**:
- `id`: UUID (clave primaria).
- `sender_id`: UUID (clave foránea a `users.id`).
- `receiver_id`: UUID (clave foránea a `users.id`).
- `content`: Text (requerido).
- `read`: Boolean (default: false).
- `created_at`: Timestamp.


**Índices**:
- `sender_id`: Para agrupar mensajes enviados.
- `receiver_id`: Para agrupar mensajes recibidos.
- `created_at`: Para ordenar conversaciones.


---


### 7. `configurations`
**Descripción**: Guarda los ajustes generales del marketplace, como comisiones o moneda predeterminada.


**Campos**:
- `id`: UUID (clave primaria).
- `key`: String (ej. "commission_rate", "default_currency").
- `value`: JSONB (valor configurable, ej. {"commission_rate": 0.1}).
- `updated_at`: Timestamp.


**Índices**:
- `key`: Único.


---


## Relaciones
- **Usuarios y Listings**: Un usuario (vendedor) puede crear múltiples listings (1:N).
- **Listings y Transacciones**: Un listing puede tener múltiples transacciones (1:N).
- **Usuarios y Suscripciones**: Un usuario puede tener una suscripción activa (1:1).
- **Usuarios y Mensajes**: Un usuario puede enviar y recibir múltiples mensajes (N:N).
- **Configuraciones**: Tabla independiente para ajustes globales del marketplace.


## Consideraciones de Rendimiento
- **Búsqueda de Texto Completo**: Crear índices en `listings.title` y `listings.description` para búsquedas rápidas.
- **Paginación**: Implementar límites y offsets en consultas de listings y mensajes para mejorar la eficiencia.
- **Caché**: Almacenar los datos de la tabla `configurations` en memoria para acceso rápido a ajustes frecuentes.


## Ejemplos de Consultas
1. **Obtener listings con filtros dinámicos**:
   ```sql
   SELECT * FROM listings
   WHERE category = 'autos'
   AND (custom_fields->>'marca') = 'Toyota'
   AND price BETWEEN 10000 AND 20000;
   ```


2. **Calcular comisiones de transacciones completadas**:
   ```sql
   SELECT t.*, (t.amount * (c.value->>'commission_rate')::numeric) AS commission
   FROM transactions t
   JOIN configurations c ON c.key = 'commission_rate'
   WHERE t.status = 'completed';
   ```


## Políticas de Acceso (RLS en Supabase)
- **Usuarios**: Solo el propietario puede editar su perfil.
- **Listings**: Solo el autor puede editarlos; todos pueden ver los listings con `status = 'active'`.
- **Transacciones**: Solo el comprador y los administradores pueden ver los detalles.
- **Mensajes**: Solo el remitente y el destinatario tienen acceso.
- **Configuraciones**: Solo los administradores pueden modificarlas.


## Diagrama del Modelo de Datos
```
users ----(1:N)---- listings ----(1:N)---- transactions
  |                    |
  |                    |
 (1:1)               (1:N)
  |                    |
subscriptions       messages
  |
 (N:N)
  |
configurations
```


---




---


# Sección 3: Requerimientos Técnicos


## Introducción
Este documento describe las especificaciones técnicas para el desarrollo de **MarketFlex**, un boilerplate SaaS flexible para marketplaces personalizables. Define las tecnologías a utilizar, los requerimientos funcionales y no funcionales, y la arquitectura del sistema, garantizando que la plataforma sea eficiente, segura y adaptable a diferentes nichos, como automotriz o inmobiliario. Además, incluye integraciones con servicios externos como MercadoPago para pagos y Resend para correos electrónicos, cumpliendo con regulaciones locales e internacionales.


## Tecnologías y Herramientas
A continuación, se detallan las tecnologías seleccionadas, su propósito y la justificación de su uso:


### Frontend
- **Next.js**: Framework para renderizado eficiente (SSR y SSG), optimizando rendimiento y SEO.
- **Shadcn**: Biblioteca de componentes UI accesibles y personalizables, alineada con WCAG 2.1.
- **TypeScript**: Tipado estático para reducir errores y mejorar la mantenibilidad.
- **next-themes**: Soporte para temas múltiples (claro, oscuro, etc.), mejorando la experiencia de usuario.
- **next-intl**: Internacionalización para múltiples idiomas y regiones.


### Backend y Base de Datos
- **Supabase**: Plataforma BaaS con autenticación, base de datos PostgreSQL, almacenamiento y funcionalidad en tiempo real.
- **PostgreSQL (Supabase)**: Base de datos relacional escalable para gestionar usuarios, listings y transacciones.
- **Supabase Realtime**: Notificaciones en tiempo real para mensajería y actualizaciones.


### Integraciones Externas
- **MercadoPago SDK**: Procesamiento de pagos únicos y suscripciones, con soporte para múltiples métodos de pago.
- **Resend**: Envío de correos electrónicos para autenticación y notificaciones.
- **react-cookie-consent**: Banner de cookies para cumplir con regulaciones como GDPR.


### Herramientas de Desarrollo y Despliegue
- **Vercel**: Despliegue escalable con CDN global y soporte para frontend y backend.
- **GitHub**: Control de versiones y colaboración.
- **Jest y React Testing Library**: Pruebas unitarias e integración para garantizar calidad.


## Requerimientos Funcionales
Los requerimientos funcionales describen las funcionalidades clave del sistema:


- **RF1**: Registro e inicio de sesión con email/contraseña o autenticación social (Google, GitHub).
- **RF2**: Envío de correos de confirmación y recuperación de contraseñas vía Resend.
- **RF3**: Creación, edición y visualización de listings con campos dinámicos por nicho.
- **RF4**: Búsqueda avanzada con filtros dinámicos y paginación para listings.
- **RF5**: Carrito de compras y checkout seguro integrado con MercadoPago.
- **RF6**: Mensajería interna con notificaciones en tiempo real.
- **RF7**: Gestión de suscripciones para vendedores con pagos recurrentes vía MercadoPago.
- **RF8**: Panel de administración para gestionar usuarios, listings y transacciones.
- **RF9**: Soporte para múltiples monedas y configuraciones regionales.
- **RF10**: Banner de cookies con opciones de aceptación/rechazo.


## Requerimientos No Funcionales
Los requerimientos no funcionales especifican las cualidades del sistema:


- **RNF1 - Rendimiento**: Carga en menos de 2 segundos en conexiones estándar.
- **RNF2 - Escalabilidad**: Soporte para 5,000 usuarios concurrentes y miles de listings.
- **RNF3 - Seguridad**: Protección contra CSRF, XSS, SQL Injection y cifrado de datos.
- **RNF4 - Usabilidad**: Interfaz intuitiva y accesible (WCAG 2.1).
- **RNF5 - Disponibilidad**: Uptime del 99.9% con Vercel.
- **RNF6 - Mantenibilidad**: Código basado en principios SOLID y bien documentado.
- **RNF7 - Cumplimiento Legal**: Soporte para GDPR y leyes locales.
- **RNF8 - Internacionalización**: Configurable por idioma y moneda.


## Integraciones Clave
El sistema integra servicios externos esenciales:


### MercadoPago
- **Uso**: Pagos únicos y suscripciones.
- **Funcionalidad**: 
  - Métodos de pago variados (tarjetas, transferencias, efectivo).
  - Webhooks para notificar eventos de pago.
  - Configuración de comisiones.


### Resend
- **Uso**: Correos electrónicos.
- **Funcionalidad**: 
  - Confirmación, recuperación y notificaciones.
  - Alta entregabilidad con SPF/DKIM.


### Supabase
- **Uso**: Autenticación, base de datos y notificaciones.
- **Funcionalidad**: 
  - Gestión de usuarios con RLS.
  - Listings dinámicos con JSONB.
  - Notificaciones en tiempo real.


## Arquitectura del Sistema
MarketFlex utiliza un enfoque ligero basado en Next.js y Supabase:
- **Frontend**: Next.js para renderizado eficiente.
- **Backend**: Supabase para autenticación y lógica.
- **Integraciones**: MercadoPago y Resend.
- **Despliegue**: Vercel para escalabilidad.


### Diagrama de Arquitectura
```
[Usuario] --> [Frontend: Next.js] --> [Backend: Supabase] --> [Base de Datos: PostgreSQL]
                           |                     |
                       [MercadoPago]          [Resend]
                           |                     |
                      [Storage: Supabase]    [Realtime: Supabase]
```


## Estructura de la Base de Datos (Supabase)
- **users**: (id, email, username, role, subscription_id).
- **listings**: (id, title, description, price, custom_fields, status).
- **listing_configurations**: (category, fields, required_fields).
- **transactions**: (id, listing_id, buyer_id, type, amount, status).
- **subscriptions**: (id, plan_name, price, features).
- **messages**: (id, sender_id, receiver_id, content, read).
- **configurations**: (key, value).


**Índices**:
- `users.email`, `users.username`: Únicos.
- `listings.category`, `listings.price`: Consultas rápidas.
- `transactions.listing_id`, `transactions.buyer_id`: Historial.


## Justificación del Diseño
- **Supabase**: Escalable y flexible con JSONB para listings dinámicos.
- **MercadoPago**: Ideal para pagos en Latinoamérica.
- **Next.js y Vercel**: Rendimiento y despliegue optimizados.


---




---


# Sección 4: Historias de Usuario


## Introducción
Las historias de usuario son una herramienta clave en el desarrollo ágil, ya que describen las funcionalidades desde la perspectiva del usuario final. En **MarketFlex**, un boilerplate SaaS para marketplaces personalizables, estas historias garantizan que el desarrollo se centre en las necesidades reales de los usuarios: compradores, vendedores y administradores. Este documento detalla las historias prioritarias para el Producto Mínimo Viable (MVP), asegurando que la plataforma sea funcional y útil desde su lanzamiento.


## Objetivos
- Identificar las necesidades clave de los diferentes roles en el marketplace.
- Establecer criterios de éxito claros para cada funcionalidad.
- Priorizar las historias para enfocarse en el MVP.


## Roles Principales
- **Comprador**: Busca, explora y compra productos o servicios.
- **Vendedor**: Publica y gestiona listings en el marketplace.
- **Administrador**: Gestiona el marketplace, incluyendo usuarios, listings y configuraciones.


## Historias de Usuario Prioritarias


### Historias para Compradores


#### HU1: Registro y Autenticación
**Como** potencial comprador, **quiero** registrarme e iniciar sesión de forma segura **para** acceder a las funcionalidades del marketplace.


**Criterios de Éxito**:
- Registro con email y contraseña.
- Envío de un correo de confirmación.
- Inicio de sesión con email y contraseña.
- Opción para recuperar contraseña olvidada.
- Registro/inicio de sesión opcional con Google o GitHub.


---


#### HU2: Búsqueda y Filtrado de Listings
**Como** comprador, **quiero** buscar y filtrar listings **para** encontrar rápidamente lo que me interesa.


**Criterios de Éxito**:
- Barra de búsqueda con autocompletado.
- Filtros dinámicos (ej. precio, categoría, ubicación).
- Resultados paginados y ordenables.


---


#### HU3: Visualización de Detalles de un Listing
**Como** comprador, **quiero** ver los detalles completos de un listing **para** evaluar si cumple con mis necesidades.


**Criterios de Éxito**:
- Página con título, descripción, precio, imágenes y campos personalizados.
- Opción de contactar al vendedor o añadir al carrito.


---


#### HU4: Carrito de Compras y Checkout
**Como** comprador, **quiero** añadir listings a mi carrito y completar la compra **para** adquirir productos de forma segura.


**Criterios de Éxito**:
- Añadir/eliminar items del carrito.
- Visualizar el total y pagar con MercadoPago.
- Confirmación y notificación por email.


---


#### HU5: Mensajería con Vendedores
**Como** comprador, **quiero** enviar mensajes a los vendedores **para** resolver dudas o negociar.


**Criterios de Éxito**:
- Mensajería accesible desde el listing o perfil del vendedor.
- Notificaciones en tiempo real.


---


### Historias para Vendedores


#### HU6: Publicación de un Listing
**Como** vendedor, **quiero** crear y publicar un listing **para** ofrecer mis productos o servicios.


**Criterios de Éxito**:
- Formulario dinámico con campos personalizados.
- Subida de imágenes y previsualización.
- Notificación al publicar.


---


#### HU7: Gestión de Listings
**Como** vendedor, **quiero** editar o eliminar mis listings **para** mantener mi oferta actualizada.


**Criterios de Éxito**:
- Dashboard con todos mis listings.
- Opciones para editar, cambiar estado o eliminar.


---


#### HU8: Suscripción a Planes
**Como** vendedor, **quiero** suscribirme a un plan premium **para** acceder a beneficios adicionales.


**Criterios de Éxito**:
- Visualización de planes y beneficios.
- Pago recurrente vía MercadoPago.


---


#### HU9: Mensajería con Compradores
**Como** vendedor, **quiero** responder a mensajes de compradores **para** cerrar ventas.


**Criterios de Éxito**:
- Interfaz de mensajería con notificaciones.
- Historial de conversaciones.


---


### Historias para Administradores


#### HU10: Configuración del Marketplace
**Como** administrador, **quiero** configurar los ajustes generales **para** adaptarlo a mi nicho.


**Criterios de Éxito**:
- Panel para definir moneda, comisiones y categorías.
- Configuración de métodos de pago.


---


#### HU11: Gestión de Usuarios
**Como** administrador, **quiero** gestionar usuarios **para** moderar la plataforma.


**Criterios de Éxito**:
- Lista de usuarios con filtros.
- Opciones para suspender o eliminar cuentas.


---


#### HU12: Moderación de Listings
**Como** administrador, **quiero** revisar y aprobar listings **para** garantizar calidad.


**Criterios de Éxito**:
- Cola de listings pendientes.
- Opciones para aprobar o rechazar.


---


### Historias Generales


#### HU13: Consentimiento de Cookies
**Como** usuario, **quiero** dar mi consentimiento sobre cookies **para** cumplir con regulaciones.


**Criterios de Éxito**:
- Banner de cookies al ingresar.
- Opción de aceptar/rechazar.


---


## Priorización para el MVP
Las historias esenciales para el MVP son:
- HU1: Registro y Autenticación.
- HU2: Búsqueda y Filtrado de Listings.
- HU3: Visualización de Detalles de un Listing.
- HU4: Carrito de Compras y Checkout.
- HU6: Publicación de un Listing.
- HU10: Configuración del Marketplace.
- HU13: Consentimiento de Cookies.


Estas forman la base funcional del marketplace.


## Conclusión
El **Documento 4: Historias de Usuario** ofrece una guía clara para desarrollar **MarketFlex**, alineando las funcionalidades con las necesidades de los usuarios. Los criterios de éxito aseguran un MVP funcional y atractivo.


---




---


# Sección 5: Diseño de la Arquitectura


## Introducción
El **Diseño de la Arquitectura** de **MarketFlex** define la estructura técnica del boilerplate, proporcionando una visión clara de cómo los componentes del sistema interactúan para cumplir con los requerimientos funcionales y no funcionales establecidos previamente. Esta arquitectura está diseñada para ser modular, escalable y fácil de mantener, permitiendo a los desarrolladores implementar marketplaces personalizados de manera eficiente.


## Objetivos
- Proporcionar una arquitectura clara y modular que soporte múltiples nichos de marketplace.
- Garantizar la escalabilidad para manejar miles de usuarios y listings concurrentes.
- Asegurar la seguridad y el cumplimiento legal mediante integraciones y configuraciones adecuadas.
- Facilitar la integración con servicios externos como MercadoPago y Resend.


## Arquitectura General
**MarketFlex** sigue una arquitectura basada en **microservicios ligeros** con un enfoque en la nube, utilizando tecnologías modernas para maximizar la flexibilidad y el rendimiento. La arquitectura se divide en tres capas principales:


1. **Capa de Presentación (Frontend)**: Interfaz de usuario accesible desde navegadores y dispositivos móviles.
2. **Capa de Lógica de Negocio (Backend)**: APIs que gestionan las operaciones y la lógica del marketplace.
3. **Capa de Datos**: Almacenamiento y recuperación de datos en tiempo real.


### Diagrama de Arquitectura
```
[Usuario] --> [Frontend: Next.js] --> [Backend: Supabase API] --> [Base de Datos: PostgreSQL]
                           |                     |
                       [MercadoPago]          [Resend]
                           |                     |
                      [Storage: Supabase]    [Realtime: Supabase]
```


## Componentes Principales


### 1. Frontend
- **Tecnología**: Next.js (React con SSR y SSG).
- **Funcionalidad**:
  - Interfaz responsiva para registro, búsqueda de listings, gestión de carrito, mensajería y panel de administración.
  - Consumo de APIs REST y suscripción a eventos en tiempo real para notificaciones.
- **Despliegue**: Vercel (hosting y CDN integrados).
- **Motivación**: Next.js optimiza el rendimiento con renderizado del lado del servidor y generación estática, simplificando el desarrollo.


### 2. Backend
- **Tecnología**: Supabase (Backend-as-a-Service) con API REST y Realtime.
- **Funcionalidad**:
  - Autenticación (email/contraseña, Google, GitHub).
  - Operaciones CRUD para listings, transacciones, suscripciones y mensajes.
  - Procesamiento de pagos y suscripciones con MercadoPago.
  - Notificaciones en tiempo real.
- **Motivación**: Supabase ofrece una solución escalable con autenticación y base de datos integradas, acelerando el desarrollo.


### 3. Base de Datos
- **Tecnología**: PostgreSQL (proporcionado por Supabase).
- **Estructura**:
  - `users`: Datos de usuarios (id, email, role, subscription_id).
  - `listings`: Listings dinámicos (id, title, description, price, custom_fields).
  - `transactions`: Compras y contactos (id, listing_id, buyer_id, type, status).
  - `subscriptions`: Planes de suscripción (id, plan_name, price, features).
  - `messages`: Conversaciones (id, sender_id, receiver_id, content).
  - `configurations`: Ajustes generales (key, value).
- **Motivación**: PostgreSQL es robusto y soporta campos JSONB para listings dinámicos.


### 4. Integraciones Externas
- **MercadoPago**: Procesamiento de pagos y suscripciones con webhooks.
- **Resend**: Envío de correos electrónicos para notificaciones y confirmaciones.
- **Supabase Storage**: Almacenamiento de imágenes con control de acceso.


### 5. Notificaciones en Tiempo Real
- **Tecnología**: Supabase Realtime.
- **Funcionalidad**: Notificaciones instantáneas para mensajes y actualizaciones.
- **Motivación**: Mejora la experiencia del usuario con interactividad en tiempo real.


## Flujo de Datos Ejemplo: Creación de un Listing
1. El vendedor accede al formulario de creación en el frontend (Next.js).
2. El frontend envía una solicitud POST a la API de Supabase con los datos del listing.
3. Supabase valida la autenticación, guarda el listing y retorna una respuesta.
4. El frontend muestra una confirmación.
5. Supabase emite un evento en tiempo real para notificar a suscriptores (ej. administradores).


## Consideraciones Técnicas
- **Escalabilidad**: Vercel y Supabase escalan automáticamente según la demanda.
- **Seguridad**:
  - HTTPS y JWT para autenticación.
  - Políticas de Row Level Security (RLS) en Supabase.
  - Sanitización de entradas.
- **Rendimiento**:
  - Índices en PostgreSQL para búsquedas rápidas.
  - Caching de datos frecuentes.
  - CDN para assets estáticos.
- **Mantenibilidad**: Código modular y documentado.


## Conclusión
Esta arquitectura proporciona una base sólida para el desarrollo del MVP de **MarketFlex**, alineándose con los requerimientos técnicos y las historias de usuario. La combinación de Next.js, Supabase y las integraciones externas asegura un desarrollo rápido, escalable y seguro.


---




---


# Sección 6: Plan de Desarrollo


## Introducción
El **Plan de Desarrollo** de **MarketFlex** Describe las fases, hitos y cronograma necesarios para la construcción del MVP del boilerplate de marketplace SaaS. Este documento guía al equipo de desarrollo desde la configuración inicial hasta el despliegue, asegurando que las funcionalidades prioritarias se implementen de manera ordenada y eficiente. Además, identifica los recursos necesarios, las dependencias entre tareas y los posibles riesgos, proporcionando una hoja de ruta clara para el lanzamiento.


## Objetivos
- Dividir el desarrollo en fases manejables con hitos claros.
- Establecer un cronograma realista para la implementación del MVP.
- Identificar recursos, dependencias y riesgos para mitigar posibles retrasos.
- Asegurar que el desarrollo se alinee con las historias de usuario y la arquitectura técnica.


## Fases de Desarrollo
El desarrollo de **MarketFlex** se dividirá en cinco fases principales:


### Fase 1: Configuración Inicial y Autenticación
**Duración Estimada**: 1 semana  
**Objetivo**: Establecer la base técnica del proyecto y configurar la autenticación de usuarios.  
**Tareas**:  
- Inicializar el proyecto con Next.js y TypeScript.  
- Configurar Supabase para autenticación, base de datos y almacenamiento.  
- Implementar registro e inicio de sesión con email/contraseña y opciones sociales (Google, GitHub).  
- Integrar Resend para enviar correos de confirmación y recuperación de contraseñas.  
- Configurar el banner de consentimiento de cookies con react-cookie-consent.  
**Hitos**:  
- Proyecto base configurado y desplegado en Vercel.  
- Autenticación funcional y probada.  
**Dependencias**:  
- Claves de API de Supabase y Resend.


---


### Fase 2: Implementación de Listings Dinámicos
**Duración Estimada**: 2 semanas  
**Objetivo**: Desarrollar la funcionalidad central de creación y visualización de listings con campos personalizables.  
**Tareas**:  
- Diseñar e implementar la interfaz para crear listings con campos dinámicos.  
- Configurar la base de datos para almacenar listings y configuraciones de campos por categoría.  
- Desarrollar la lista de listings con búsqueda avanzada, filtros dinámicos y paginación.  
- Implementar la vista detallada de un listing con opción de contacto o añadir al carrito.  
**Hitos**:  
- Creación y visualización de listings operativas.  
- Búsqueda y filtros funcionales.  
**Dependencias**:  
- Autenticación completada (Fase 1).


---


### Fase 3: Carrito de Compras y Pagos con MercadoPago
**Duración Estimada**: 2 semanas  
**Objetivo**: Implementar el sistema de carrito de compras y la integración con MercadoPago para pagos únicos.  
**Tareas**:  
- Desarrollar el carrito de compras con opciones para añadir/eliminar items.  
- Integrar MercadoPago para procesar pagos con múltiples métodos (tarjetas, transferencias, efectivo).  
- Implementar webhooks para manejar eventos de pago (aprobado, rechazado).  
- Configurar notificaciones por email para confirmación de transacciones.  
**Hitos**:  
- Carrito de compras y checkout completamente funcionales.  
- Integración con MercadoPago probada y operativa.  
**Dependencias**:  
- Implementación de listings completada (Fase 2).


---


### Fase 4: Suscripciones para Vendedores y Mensajería Interna
**Duración Estimada**: 2 semanas  
**Objetivo**: Añadir funcionalidades de suscripciones para vendedores y mensajería interna para comunicación entre usuarios.  
**Tareas**:  
- Implementar planes de suscripción para vendedores con pagos recurrentes vía MercadoPago.  
- Desarrollar el sistema de mensajería interna con notificaciones en tiempo real.  
- Configurar Supabase Realtime para actualizaciones instantáneas en conversaciones.  
**Hitos**:  
- Suscripciones y mensajería completamente funcionales.  
- Notificaciones en tiempo real operativas.  
**Dependencias**:  
- Carrito de compras y pagos completados (Fase 3).


---


### Fase 5: Panel de Administración, Pruebas y Despliegue
**Duración Estimada**: 2 semanas  
**Objetivo**: Implementar el panel de administración, realizar pruebas exhaustivas y desplegar la plataforma en producción.  
**Tareas**:  
- Desarrollar el panel de administración para gestionar usuarios, listings y configuraciones generales.  
- Ejecutar pruebas unitarias, de integración y end-to-end.  
- Realizar pruebas de rendimiento y seguridad.  
- Desplegar la aplicación en Vercel y verificar configuraciones de producción.  
- Documentar el proceso de despliegue y configuración.  
**Hitos**:  
- Panel de administración funcional.  
- Aplicación desplegada y lista para uso en producción.  
- Documentación de despliegue completa.  
**Dependencias**:  
- Todas las fases anteriores completadas.


---


## Cronograma Estimado
El cronograma total para el desarrollo del MVP es de **9 semanas**, dividido de la siguiente manera:


| Fase                             | Duración  | Fecha Inicio | Fecha Fin |
|----------------------------------|-----------|--------------|-----------|
| Fase 1: Configuración Inicial    | 1 semana  | Semana 1     | Semana 1  |
| Fase 2: Listings Dinámicos       | 2 semanas | Semana 2     | Semana 3  |
| Fase 3: Carrito y Pagos          | 2 semanas | Semana 4     | Semana 5  |
| Fase 4: Suscripciones y Mensajería | 2 semanas | Semana 6     | Semana 7  |
| Fase 5: Administración, Pruebas y Despliegue | 2 semanas | Semana 8     | Semana 9  |


**Nota**: Este cronograma es estimado y puede ajustarse según el progreso real y las necesidades del equipo.


---


## Recursos Necesarios
- **Equipo de Desarrollo**:  
  - 1-2 desarrolladores full-stack con experiencia en Next.js, TypeScript, Supabase y MercadoPago.  
  - 1 diseñador UX/UI (opcional, para refinamiento de la interfaz).  
- **Herramientas**:  
  - GitHub para control de versiones.  
  - Vercel para despliegue y hosting.  
  - Figma o similar para prototipos (si es necesario).  
- **Tecnologías**:  
  - Next.js, Supabase, TypeScript, Shadcn, next-themes, next-intl, react-cookie-consent, Resend, MercadoPago SDK.


---


## Dependencias Clave
- **Autenticación**: Debe estar completa antes de implementar la creación de listings.  
- **Listings Dinámicos**: Necesarios para probar el carrito de compras y pagos.  
- **Carrito y Pagos**: Deben funcionar antes de implementar suscripciones y mensajería.  
- **Suscripciones y Mensajería**: Pueden desarrollarse en paralelo, pero dependen de la autenticación y los listings.


---


## Riesgos y Mitigaciones
| Riesgo                              | Impacto    | Mitigación                                      |
|-------------------------------------|------------|-------------------------------------------------|
| Retrasos en la configuración de Supabase | Alto       | Documentar y probar la configuración previamente. |
| Problemas de rendimiento con listings dinámicos | Medio      | Optimizar consultas y usar índices adecuados.   |
| Dificultades con la integración de MercadoPago | Alto       | Realizar pruebas tempranas y seguir la documentación oficial. |
| Errores en la integración de Resend | Bajo       | Probar envíos de correos en desarrollo.         |


---


## Conclusión
Este **Plan de Desarrollo** proporciona una hoja de ruta clara y estructurada para construir el MVP de **MarketFlex** en un plazo estimado de 9 semanas. Siguiendo las fases, hitos y cronograma definidos, el equipo podrá enfocarse en entregar funcionalidades clave de manera iterativa, asegurando que la plataforma sea funcional, escalable y lista para su lanzamiento.


---




---


# Sección 7: Estrategia de Pruebas


## Introducción
La **Estrategia de Pruebas** para **MarketFlex** define un enfoque sistemático para validar la calidad del boilerplate de marketplace SaaS durante su desarrollo y antes del lanzamiento del MVP. Este documento detalla los tipos de pruebas, herramientas, criterios de éxito, gestión de defectos y la integración con el proceso de desarrollo, asegurando que la plataforma sea robusta, segura y eficiente, cumpliendo con los requerimientos funcionales y no funcionales establecidos previamente.


## Objetivos
- Validar el correcto funcionamiento del frontend (Next.js), backend (Supabase) y las integraciones externas (MercadoPago, Resend).
- Asegurar que las funcionalidades clave, como listings dinámicos, procesamiento de pagos y mensajería en tiempo real, operen sin errores.
- Garantizar la escalabilidad y rendimiento bajo carga, soportando miles de usuarios concurrentes.
- Detectar y mitigar vulnerabilidades de seguridad, cumpliendo con estándares como GDPR y regulaciones locales.


## Tipos de Pruebas
A continuación, se describen los tipos de pruebas que se implementarán para cubrir todos los aspectos críticos del sistema:


### 1. Pruebas Unitarias
- **Objetivo**: Verificar que cada componente individual (funciones, clases, componentes de React) funcione correctamente de manera aislada.
- **Alcance**: Lógica de negocio, como la validación de campos dinámicos en listings, cálculos de comisiones y renderizado de componentes UI.


### 2. Pruebas de Integración
- **Objetivo**: Confirmar que los módulos y servicios interactúen sin problemas, especialmente las integraciones con Supabase y MercadoPago.
- **Alcance**: Conexiones entre el frontend y el backend, llamadas a APIs externas y operaciones en la base de datos.


### 3. Pruebas End-to-End (E2E)
- **Objetivo**: Simular el comportamiento real del usuario y validar flujos completos de la aplicación, como registro, creación de listings y procesamiento de pagos.
- **Alcance**: Procesos clave que involucran múltiples componentes y servicios.


### 4. Pruebas de Rendimiento
- **Objetivo**: Evaluar la capacidad de la plataforma bajo carga y garantizar tiempos de respuesta adecuados.
- **Alcance**: Pruebas de carga y estrés para el frontend, backend y base de datos, simulando miles de usuarios concurrentes.


### 5. Pruebas de Seguridad
- **Objetivo**: Identificar y mitigar vulnerabilidades comunes, como CSRF, XSS, SQL Injection y problemas de autenticación.
- **Alcance**: Pruebas automatizadas y revisiones manuales de seguridad, especialmente en áreas sensibles como pagos y datos personales.


## Herramientas de Pruebas
Las siguientes herramientas han sido seleccionadas para cada tipo de prueba, basadas en el stack tecnológico de **MarketFlex**:


| **Tipo de Prueba**         | **Herramienta(s)**            |
|----------------------------|-------------------------------|
| Pruebas Unitarias          | Jest, React Testing Library   |
| Pruebas de Integración     | Jest, Supabase mocks          |
| Pruebas E2E                | Cypress                       |
| Pruebas de Rendimiento     | Lighthouse, k6                |
| Pruebas de Seguridad       | OWASP ZAP, revisiones manuales|


## Criterios de Éxito
Para considerar las pruebas exitosas, se establecen los siguientes criterios:


- **Pruebas Unitarias**: Cobertura mínima del 80% del código.
- **Pruebas de Integración**: Todas las integraciones clave deben funcionar sin errores.
- **Pruebas E2E**: Los flujos principales del usuario deben completarse sin fallos.
- **Pruebas de Rendimiento**: La aplicación debe cargar en menos de 2 segundos y soportar al menos 1,000 usuarios concurrentes con tiempos de respuesta aceptables.
- **Pruebas de Seguridad**: No se deben detectar vulnerabilidades críticas.


## Gestión de Defectos
El proceso para manejar defectos será el siguiente:


- **Reporte**: Los defectos se registrarán en GitHub Issues con etiquetas según su severidad (crítico, alto, medio, bajo).
- **Priorización**: Los defectos críticos bloquean el despliegue; los menores se abordan en sprints futuros.
- **Resolución**: Los defectos serán asignados a los desarrolladores según el área afectada.


## Automatización y CI/CD
- **Integración Continua**: Las pruebas unitarias y de integración se ejecutarán automáticamente en cada pull request mediante GitHub Actions.
- **Despliegue**: Solo se permitirá el despliegue si todas las pruebas pasan con éxito.


## Cronograma de Pruebas
- **Pruebas Unitarias**: Durante el desarrollo de cada funcionalidad.
- **Pruebas de Integración**: Al completar cada fase de integración.
- **Pruebas E2E**: Antes del despliegue del MVP.
- **Pruebas de Rendimiento y Seguridad**: En la fase final, previo al lanzamiento.


## Responsabilidades
- **Desarrolladores**: Crear y mantener pruebas unitarias y de integración.
- **Equipo de QA/Testers**: Ejecutar pruebas E2E, de rendimiento y seguridad.
- **Equipo de Seguridad**: Realizar revisiones de código y pruebas de penetración.


## Ejemplos de Pruebas Clave
- **Unitaria**: Verificar que un campo dinámico en un listing se valide correctamente.
- **Integración**: Confirmar que una transacción se registra correctamente en Supabase tras un pago exitoso en MercadoPago.
- **E2E**: Simular el flujo completo de un comprador: registro, búsqueda, añadir al carrito y pagar.
- **Rendimiento**: Medir el tiempo de carga de la lista de listings con 1,000 usuarios concurrentes.
- **Seguridad**: Intentar inyecciones SQL en formularios de búsqueda.


## Conclusión
Esta **Estrategia de Pruebas** asegura que **MarketFlex** sea una plataforma robusta, segura y eficiente. Al seguir este plan, el equipo podrá detectar y corregir defectos de manera temprana, garantizando un lanzamiento exitoso del MVP.


---


























---






# Sección 8: Documentación de APIs


## Introducción
La **Documentación de APIs** de **MarketFlex** describe los endpoints RESTful que permiten interactuar con la plataforma, cubriendo operaciones para gestionar usuarios, listings, transacciones, suscripciones, mensajes y configuraciones. Cada endpoint está diseñado para ser seguro, eficiente y fácil de usar, siguiendo las mejores prácticas de diseño de APIs. Esta documentación está dirigida a desarrolladores que integrarán el frontend con el backend o extenderán las funcionalidades de la plataforma.


Para utilizar esta API, es necesario autenticarse y obtener un token JWT, que debe incluirse en el encabezado `Authorization` de las solicitudes protegidas.


---


## Autenticación
MarketFlex utiliza **Supabase** para la autenticación. Los usuarios pueden registrarse e iniciar sesión con email y contraseña, o mediante proveedores sociales como Google y GitHub.


### Registro
- **Método**: `POST`
- **Endpoint**: `/auth/signup`
- **Parámetros**:
  - Cuerpo de la solicitud:
    ```json
    {
      "email": "string",
      "password": "string"
    }
    ```
- **Respuesta Exitosa** (200 OK):
  ```json
  {
    "access_token": "jwt",
    "user": {
      "id": "uuid",
      "email": "string",
      "role": "string"
    }
  }
  ```


### Inicio de Sesión
- **Método**: `POST`
- **Endpoint**: `/auth/signin`
- **Parámetros**:
  - Cuerpo de la solicitud:
    ```json
    {
      "email": "string",
      "password": "string"
    }
    ```
- **Respuesta Exitosa** (200 OK):
  ```json
  {
    "access_token": "jwt",
    "user": {
      "id": "uuid",
      "email": "string",
      "role": "string"
    }
  }
  ```


### Autenticación Social
Redirige al usuario a la URL del proveedor (por ejemplo, `/auth/google`) y maneja el callback para obtener el token JWT.


**Nota**: El token JWT debe incluirse en el encabezado `Authorization: Bearer <token>` para todas las solicitudes autenticadas.


---


## Endpoints Principales


### 1. Usuarios


#### 1.1 Obtener Perfil de Usuario
- **Método**: `GET`
- **Endpoint**: `/api/users/:id`
- **Descripción**: Obtiene los detalles de un usuario específico.
- **Parámetros**:
  - `id` (path): ID del usuario.
- **Respuesta Exitosa** (200 OK):
  ```json
  {
    "id": "uuid",
    "username": "string",
    "email": "string",
    "role": "string",
    "bio": "string",
    "avatar_url": "string",
    "created_at": "timestamp"
  }
  ```
- **Ejemplo**:
  ```
  GET /api/users/123e4567-e89b-12d3-a456-426614174000
  ```


#### 1.2 Actualizar Perfil de Usuario
- **Método**: `PUT`
- **Endpoint**: `/api/users/:id`
- **Descripción**: Actualiza los datos del perfil del usuario autenticado.
- **Parámetros**:
  - `id` (path): ID del usuario.
  - Cuerpo de la solicitud:
    ```json
    {
      "username": "string",
      "bio": "string",
      "avatar_url": "string"
    }
    ```
- **Respuesta Exitosa** (200 OK):
  ```json
  {
    "message": "Perfil actualizado exitosamente"
  }
  ```
- **Notas**: Requiere autenticación y que el usuario sea el propietario del perfil.


---


### 2. Listings


#### 2.1 Crear un Listing
- **Método**: `POST`
- **Endpoint**: `/api/listings`
- **Descripción**: Crea un nuevo listing.
- **Parámetros**:
  - Cuerpo de la solicitud:
    ```json
    {
      "title": "string",
      "description": "string",
      "price": "number",
      "category": "string",
      "custom_fields": { "key": "value" }
    }
    ```
- **Respuesta Exitosa** (201 Created):
  ```json
  {
    "id": "uuid",
    "title": "string",
    "description": "string",
    "price": "number",
    "category": "string",
    "custom_fields": { "key": "value" },
    "author_id": "uuid",
    "created_at": "timestamp"
  }
  ```
- **Notas**: Requiere autenticación y rol de vendedor.


#### 2.2 Obtener Lista de Listings
- **Método**: `GET`
- **Endpoint**: `/api/listings`
- **Descripción**: Obtiene una lista paginada de listings con filtros.
- **Parámetros**:
  - `page` (query): Número de página (default: 1).
  - `limit` (query): Número de listings por página (default: 10).
  - `search` (query): Término de búsqueda (opcional).
  - `filters` (query): Filtros personalizados, ej. `price_min`, `price_max`, `category`.
- **Respuesta Exitosa** (200 OK):
  ```json
  {
    "listings": [
      {
        "id": "uuid",
        "title": "string",
        "description": "string",
        "price": "number",
        "category": "string",
        "author": {
          "id": "uuid",
          "username": "string"
        },
        "created_at": "timestamp"
      }
    ],
    "total": "integer",
    "page": "integer",
    "limit": "integer"
  }
  ```


---


### 3. Transacciones


#### 3.1 Crear una Transacción
- **Método**: `POST`
- **Endpoint**: `/api/transactions`
- **Descripción**: Inicia un proceso de pago para un listing.
- **Parámetros**:
  - Cuerpo de la solicitud:
    ```json
    {
      "listing_id": "uuid",
      "payment_method": "string" // ej. "credit_card", "transfer"
    }
    ```
- **Respuesta Exitosa** (201 Created):
  ```json
  {
    "id": "uuid",
    "status": "pending",
    "mercado_pago_url": "string" // URL para completar el pago
  }
  ```
- **Notas**: Requiere autenticación y rol de comprador.


#### 3.2 Obtener Estado de Transacción
- **Método**: `GET`
- **Endpoint**: `/api/transactions/:id`
- **Descripción**: Obtiene el estado de una transacción específica.
- **Parámetros**:
  - `id` (path): ID de la transacción.
- **Respuesta Exitosa** (200 OK):
  ```json
  {
    "id": "uuid",
    "status": "string", // "pending", "completed", "failed"
    "amount": "number",
    "currency": "string",
    "created_at": "timestamp"
  }
  ```


---


### 4. Suscripciones


#### 4.1 Crear una Suscripción
- **Método**: `POST`
- **Endpoint**: `/api/subscriptions`
- **Descripción**: Suscribe al usuario a un plan de suscripción.
- **Parámetros**:
  - Cuerpo de la solicitud:
    ```json
    {
      "plan_id": "uuid"
    }
    ```
- **Respuesta Exitosa** (201 Created):
  ```json
  {
    "id": "uuid",
    "plan_name": "string",
    "status": "active",
    "next_billing_date": "timestamp"
  }
  ```
- **Notas**: Requiere autenticación y rol de vendedor.


#### 4.2 Obtener Detalles de Suscripción
- **Método**: `GET`
- **Endpoint**: `/api/subscriptions/:id`
- **Descripción**: Obtiene los detalles de una suscripción específica.
- **Parámetros**:
  - `id` (path): ID de la suscripción.
- **Respuesta Exitosa** (200 OK):
  ```json
  {
    "id": "uuid",
    "plan_name": "string",
    "status": "string",
    "features": { "key": "value" },
    "next_billing_date": "timestamp"
  }
  ```


---


### 5. Mensajes


#### 5.1 Enviar un Mensaje
- **Método**: `POST`
- **Endpoint**: `/api/messages`
- **Descripción**: Envía un mensaje a otro usuario.
- **Parámetros**:
  - Cuerpo de la solicitud:
    ```json
    {
      "receiver_id": "uuid",
      "content": "string"
    }
    ```
- **Respuesta Exitosa** (201 Created):
  ```json
  {
    "id": "uuid",
    "sender_id": "uuid",
    "receiver_id": "uuid",
    "content": "string",
    "read": false,
    "created_at": "timestamp"
  }
  ```
- **Notas**: Requiere autenticación.


#### 5.2 Obtener Mensajes de un Usuario
- **Método**: `GET`
- **Endpoint**: `/api/messages`
- **Descripción**: Obtiene los mensajes enviados y recibidos por el usuario autenticado.
- **Parámetros**:
  - `page` (query): Número de página (default: 1).
  - `limit` (query): Número de mensajes por página (default: 10).
- **Respuesta Exitosa** (200 OK):
  ```json
  {
    "messages": [
      {
        "id": "uuid",
        "sender_id": "uuid",
        "receiver_id": "uuid",
        "content": "string",
        "read": boolean,
        "created_at": "timestamp"
      }
    ],
    "total": "integer",
    "page": "integer",
    "limit": "integer"
  }
  ```


---


### 6. Configuraciones (Solo Administradores)


#### 6.1 Obtener Configuraciones
- **Método**: `GET`
- **Endpoint**: `/api/configurations`
- **Descripción**: Obtiene las configuraciones actuales del marketplace.
- **Respuesta Exitosa** (200 OK):
  ```json
  {
    "configurations": [
      {
        "key": "string",
        "value": "json"
      }
    ]
  }
  ```
- **Notas**: Requiere autenticación y rol de administrador.


#### 6.2 Actualizar Configuración
- **Método**: `PUT`
- **Endpoint**: `/api/configurations/:key`
- **Descripción**: Actualiza el valor de una configuración específica.
- **Parámetros**:
  - `key` (path): Clave de la configuración.
  - Cuerpo de la solicitud:
    ```json
    {
      "value": "json"
    }
    ```
- **Respuesta Exitosa** (200 OK):
  ```json
  {
    "message": "Configuración actualizada exitosamente"
  }
  ```
- **Notas**: Requiere autenticación y rol de administrador.


---


## Manejo de Errores
La API utiliza códigos de estado HTTP para indicar el resultado de las solicitudes. Cada error incluye un mensaje descriptivo para facilitar la depuración.


### Errores Comunes
- **400 Bad Request**: Parámetros inválidos o faltantes.
  ```json
  {
    "error": "Parámetro 'title' es requerido"
  }
  ```
- **401 Unauthorized**: Autenticación requerida o token inválido.
  ```json
  {
    "error": "Token inválido o ausente"
  }
  ```
- **403 Forbidden**: Permisos insuficientes.
  ```json
  {
    "error": "No tienes permiso para realizar esta acción"
  }
  ```
- **404 Not Found**: Recurso no encontrado.
  ```json
  {
    "error": "Usuario no encontrado"
  }
  ```
- **500 Internal Server Error**: Error del servidor.
  ```json
  {
    "error": "Ocurrió un error interno. Contacta al soporte."
  }
  ```


---


## Paginación y Filtrado
Los endpoints que devuelven listas (como `/api/listings` y `/api/messages`) soportan paginación y filtrado:
- **Paginación**:
  - `page`: Número de página (default: 1).
  - `limit`: Elementos por página (default: 10).
- **Filtrado**: Parámetros query adicionales, como `search`, `price_min`, `price_max`, `category`, etc.
- **Ejemplo**:
  ```
  GET /api/listings?page=2&limit=5&search=auto&price_max=20000
  ```


---


## Pruebas de los Endpoints
Para probar los endpoints, recomendamos usar herramientas como **Postman** o **cURL**. A continuación, un ejemplo con cURL:


### Crear un Listing
```bash
curl -X POST "https://api.marketflex.com/api/listings" \
-H "Authorization: Bearer <JWT_TOKEN>" \
-H "Content-Type: application/json" \
-d '{
  "title": "Auto Usado Toyota",
  "description": "Toyota Corolla 2020 en excelente estado",
  "price": 15000,
  "category": "autos",
  "custom_fields": { "marca": "Toyota", "año": 2020 }
}'
```


### Respuesta Esperada
```json
{
  "id": "123e4567-e89b-12d3-a456-426614174000",
  "title": "Auto Usado Toyota",
  "description": "Toyota Corolla 2020 en excelente estado",
  "price": 15000,
  "category": "autos",
  "custom_fields": { "marca": "Toyota", "año": 2020 },
  "author_id": "uuid",
  "created_at": "2023-10-01T12:00:00Z"
}
```


---


## Consideraciones de Seguridad
- **Autenticación**: Uso de JWT para endpoints protegidos.
- **Autorización**: Políticas de **Row Level Security (RLS)** en Supabase para restringir acceso según roles.
- **Validación**: Sanitización de entradas para prevenir inyecciones.
- **Rate Limiting**: Implementado en el servidor para evitar abuso.


---


## Conclusión
Esta **Documentación de APIs** proporciona una guía completa y detallada para interactuar con los servicios de **MarketFlex**. Los endpoints están diseñados para ser intuitivos, seguros y escalables, facilitando la integración del frontend y la expansión futura de la plataforma. Si tienes preguntas o necesitas soporte adicional, contacta al equipo de desarrollo.


---










---


# Sección 9: Guía de Despliegue


## Introducción
La **Guía de Despliegue** de **MarketFlex** está diseñada para ayudarte a llevar la aplicación desde el entorno de desarrollo a producción de manera eficiente. Incluye instrucciones detalladas para configurar servicios clave como Supabase (autenticación y base de datos), MercadoPago (procesamiento de pagos), Resend (envío de correos electrónicos) y el despliegue en Vercel. Además, ofrece recomendaciones para garantizar seguridad, rendimiento y escalabilidad.


## Objetivos
- Desplegar **MarketFlex** de forma rápida y eficiente.
- Asegurar que las integraciones externas (Supabase, MercadoPago, Resend) funcionen correctamente en producción.
- Implementar buenas prácticas de seguridad y monitoreo.
- Facilitar la escalabilidad y el mantenimiento a largo plazo.


## Requisitos Previos
Antes de comenzar, asegúrate de tener lo siguiente:
- Una cuenta activa en [Vercel](https://vercel.com/) para alojar la aplicación.
- Un proyecto configurado en [Supabase](https://supabase.com/).
- Una cuenta en [MercadoPago](https://www.mercadopago.com/) con credenciales listas.
- Una cuenta en [Resend](https://resend.com/) para gestionar correos electrónicos.
- Las claves de API y credenciales de los servicios mencionados.
- El código fuente de **MarketFlex** alojado en un repositorio de GitHub.


---


## Pasos para el Despliegue


### 1. Configuración de Supabase para Producción
- **Objetivo**: Preparar Supabase para operar en un entorno de producción seguro.
- **Pasos**:
  1. Accede al dashboard de Supabase y dirígete a **Settings > General**.
  2. Activa el modo producción para habilitar configuraciones avanzadas.
  3. Habilita **Row Level Security (RLS)** en todas las tablas para controlar accesos.
  4. Genera una clave de API de producción y guárdala de forma segura.
  5. Define políticas de acceso según los roles de usuario (comprador, vendedor, administrador).


### 2. Configuración de MercadoPago
- **Objetivo**: Integrar MercadoPago para procesar pagos en producción.
- **Pasos**:
  1. Crea una cuenta en MercadoPago y obtén tu **public key** y **access token**.
  2. Configura los webhooks en MercadoPago para recibir notificaciones de pagos.
  3. Realiza pruebas en desarrollo antes de activarlo en producción.


### 3. Configuración de Resend
- **Objetivo**: Configurar Resend para enviar correos electrónicos en producción.
- **Pasos**:
  1. Regístrate en Resend y obtén tu clave de API.
  2. En Supabase, ve a **Authentication > Providers > Email** y selecciona Resend como proveedor.
  3. Ingresa la clave de API y verifica tu dominio para asegurar la entrega de correos.


### 4. Configuración de Variables de Entorno
- **Objetivo**: Establecer las variables necesarias en Vercel para conectar los servicios.
- **Pasos**:
  1. En Vercel, accede a **Settings > Environment Variables** de tu proyecto.
  2. Añade las siguientes variables:
     - `NEXT_PUBLIC_SUPABASE_URL`: URL pública de Supabase.
     - `NEXT_PUBLIC_SUPABASE_ANON_KEY`: Clave anónima de Supabase.
     - `SUPABASE_SERVICE_ROLE_KEY`: Clave de servicio de Supabase.
     - `MERCADO_PAGO_PUBLIC_KEY`: Clave pública de MercadoPago.
     - `MERCADO_PAGO_ACCESS_TOKEN`: Token de acceso de MercadoPago.
     - `RESEND_API_KEY`: Clave de API de Resend.
     - `NEXT_PUBLIC_APP_URL`: URL de producción (ej. `https://marketflex.com`).


### 5. Despliegue en Vercel
- **Objetivo**: Publicar la aplicación en producción usando Vercel.
- **Pasos**:
  1. Conecta tu repositorio de GitHub a Vercel.
  2. Selecciona la rama principal (ej. `main`) como fuente.
  3. Configura el framework como **Next.js**.
  4. Revisa las variables de entorno y haz clic en **Deploy**.


### 6. Verificación Post-Despliegue
- **Objetivo**: Confirmar que la aplicación funciona correctamente en producción.
- **Pasos**:
  1. Visita la URL generada por Vercel y prueba el registro e inicio de sesión.
  2. Crea un listing y verifica que se guarde en la base de datos de Supabase.
  3. Realiza una transacción de prueba con MercadoPago (usa montos pequeños).
  4. Envía un mensaje y comprueba las notificaciones en tiempo real.
  5. Asegúrate de que los correos se envíen correctamente mediante Resend.


### 7. Configuración de Dominio Personalizado (Opcional)
- **Objetivo**: Asociar un dominio propio a la aplicación.
- **Pasos**:
  1. En Vercel, ve a **Settings > Domains** y añade tu dominio.
  2. Configura los registros DNS según las instrucciones de Vercel.
  3. Verifica que el certificado SSL esté activo y el dominio funcione.


### 8. Monitoreo y Logging
- **Objetivo**: Habilitar herramientas para supervisar el rendimiento y errores.
- **Pasos**:
  1. Activa **Vercel Analytics** para monitorear tráfico y rendimiento.
  2. Integra herramientas como **Sentry** o **LogRocket** para capturar errores.
  3. Configura alertas para problemas críticos en producción.


---


## Mejores Prácticas para Producción
- **Seguridad**:
  - Nunca almacenes claves o secretos en el código fuente.
  - Fuerza el uso de HTTPS y redirige solicitudes HTTP.
- **Rendimiento**:
  - Activa el caching para assets estáticos y datos frecuentes.
  - Optimiza imágenes y recursos multimedia.
- **Escalabilidad**:
  - Habilita el autoescalado en Vercel para manejar picos de tráfico.
  - Monitorea y ajusta los recursos de la base de datos según la demanda.


---


## Solución de Problemas Comunes
- **Error de Autenticación**: Verifica las claves de Supabase y las políticas de RLS.
- **Pagos Fallidos**: Revisa las credenciales de MercadoPago y la configuración de webhooks.
- **Correos No Enviados**: Confirma la clave de Resend y la verificación del dominio.
- **Despliegue Fallido**: Consulta los logs de Vercel para identificar el problema.


---




















---


# Sección 10: Guía de Mejores Prácticas


## Introducción
La **Guía de Mejores Prácticas** para **MarketFlex** proporciona un marco para desarrollar un boilerplate SaaS de marketplace robusto, adaptable y fácil de mantener. Está diseñada para enfrentar desafíos como la gestión de listings dinámicos, integraciones de pagos y notificaciones en tiempo real, asegurando que el proyecto sea escalable y eficiente.


## Objetivos
- Garantizar la calidad y mantenibilidad del código.
- Optimizar el rendimiento y la escalabilidad para soportar miles de usuarios y listings.
- Facilitar la colaboración entre desarrolladores.
- Incorporar prácticas de seguridad y accesibilidad.


---


## 1. Principios SOLID
Los principios SOLID son fundamentales para crear código modular y sostenible. A continuación, se detallan con ejemplos aplicados a **MarketFlex**:


### 1.1 Single Responsibility Principle (Principio de Responsabilidad Única)
**Definición**: Cada clase o función debe tener una sola responsabilidad.  
**Ejemplo**: Separar la lógica de autenticación de la visualización de un listing.


```tsx
// Mal: Un componente hace demasiado
function ListingPage() {
  const user = useAuth(); // Autenticación
  const listing = useListing(); // Datos del listing
  return <div>{listing.title}</div>; // Visualización
}


// Bien: Responsabilidades separadas
function ListingPage({ listing }) {
  return <div>{listing.title}</div>;
}


function AuthWrapper() {
  const user = useAuth();
  const listing = useListing();
  return <ListingPage listing={listing} />;
}
```


### 1.2 Open/Closed Principle (Principio Abierto/Cerrado)
**Definición**: Las entidades deben estar abiertas a extensión pero cerradas a modificación.  
**Ejemplo**: Añadir nuevos métodos de pago sin alterar el código existente.


```tsx
class PaymentProcessor {
  constructor(type) {
    this.type = type;
  }
  process(amount) {
    throw new Error("Método no implementado");
  }
}


class MercadoPagoProcessor extends PaymentProcessor {
  process(amount) {
    return mercadoPago.charge(amount);
  }
}
```


### 1.3 Liskov Substitution Principle (Principio de Sustitución de Liskov)
**Definición**: Las subclases deben ser intercambiables por sus clases base sin afectar el comportamiento.  
**Ejemplo**: Clientes de notificaciones intercambiables.


```tsx
interface NotificationClient {
  send(to: string, message: string): Promise<void>;
}


class EmailClient implements NotificationClient {
  async send(to, message) {
    await resend.sendEmail(to, message);
  }
}
```


### 1.4 Interface Segregation Principle (Principio de Segregación de Interfaces)
**Definición**: No obligar a los clientes a depender de interfaces que no usan.  
**Ejemplo**: Interfaces separadas para Supabase.


```tsx
interface AuthClient {
  signIn(email: string, password: string): Promise<void>;
}


interface DataClient {
  fetchListings(): Promise<Listing[]>;
}


class SupabaseAuth implements AuthClient {
  async signIn(email, password) {
    await supabase.auth.signInWithPassword({ email, password });
  }
}
```


### 1.5 Dependency Inversion Principle (Principio de Inversión de Dependencias)
**Definición**: Depender de abstracciones, no de implementaciones concretas.  
**Ejemplo**: Inyección de servicios de pago.


```tsx
class PaymentService {
  constructor(private processor: PaymentProcessor) {}


  async pay(amount: number) {
    await this.processor.process(amount);
  }
}


const mercadoPagoProcessor = new MercadoPagoProcessor();
const paymentService = new PaymentService(mercadoPagoProcessor);
```


---


## 2. Clean Code
El código limpio mejora la legibilidad y el mantenimiento. Estas son las prácticas clave:


### 2.1 Nombres Descriptivos
**Práctica**: Usa nombres que revelen la intención.  
**Ejemplo**:


```tsx
// Mal
const x = await fetch("/api/listings");


// Bien
const listings = await fetchListings("/api/listings");
```


### 2.2 Funciones Pequeñas y con un Solo Propósito
**Práctica**: Las funciones deben ser cortas y enfocadas en una tarea.  
**Ejemplo**:


```tsx
// Mal
async function handleRequest(req, res) {
  const data = await supabase.from("transactions").select("*");
  res.status(200).json(data);
}


// Bien
async function getTransactions() {
  return await supabase.from("transactions").select("*");
}


async function handleRequest(req, res) {
  const transactions = await getTransactions();
  res.status(200).json(transactions);
}
```


### 2.3 Manejo de Errores
**Práctica**: Gestiona errores explícitamente.  
**Ejemplo**:


```tsx
async function createListing(data) {
  try {
    const { data: listing, error } = await supabase.from("listings").insert(data);
    if (error) throw new Error(error.message);
    return listing;
  } catch (error) {
    throw new Error(`Error al crear listing: ${error.message}`);
  }
}
```


### 2.4 Comentarios Útiles
**Práctica**: Comenta el "por qué", no el "qué".  
**Ejemplo**:


```tsx
// Mal: Redundante
// Obtiene listings
const listings = await fetchListings();


// Bien: Explica la intención
// Usamos un caché para reducir consultas a Supabase
const listings = await cachedFetchListings();
```


---


## 3. Patrones de Diseño
Los patrones de diseño resuelven problemas comunes. Aquí algunos útiles para **MarketFlex**:


### 3.1 Singleton
**Definición**: Asegura una única instancia de un recurso.  
**Ejemplo**: Conexión a Supabase.


```tsx
class SupabaseSingleton {
  private static instance: SupabaseClient;


  private constructor() {}


  static getInstance() {
    if (!SupabaseSingleton.instance) {
      SupabaseSingleton.instance = createClient(supabaseUrl, supabaseKey);
    }
    return SupabaseSingleton.instance;
  }
}
```


### 3.2 Factory
**Definición**: Centraliza la creación de objetos.  
**Ejemplo**: Procesadores de pago.


```tsx
class PaymentFactory {
  static createProcessor(type: string) {
    if (type === "mercadopago") return new MercadoPagoProcessor();
    throw new Error("Procesador no soportado");
  }
}


const processor = PaymentFactory.createProcessor("mercadopago");
```


### 3.3 Repository
**Definición**: Abstrae el acceso a datos.  
**Ejemplo**: Consultas a listings.


```tsx
interface ListingRepository {
  getListings(): Promise<Listing[]>;
}


class SupabaseListingRepository implements ListingRepository {
  async getListings() {
    const { data } = await supabase.from("listings").select("*");
    return data;
  }
}
```


---


## 4. Prácticas Específicas para Marketplaces
Para un marketplace como **MarketFlex**, se recomiendan estas prácticas adicionales:


### 4.1 Gestión de Concurrencia
**Práctica**: Usa bloqueos optimistas para transacciones concurrentes.  
**Ejemplo**: Implementa timestamps para detectar cambios simultáneos en listings.


### 4.2 Optimización de Consultas
**Práctica**: Usa índices y consultas eficientes.  
**Ejemplo**: Indexa campos como `price` y `category` en la tabla de listings.


### 4.3 Notificaciones en Tiempo Real
**Práctica**: Implementa Supabase Realtime para actualizaciones instantáneas.  
**Ejemplo**: Suscríbete a cambios en mensajes para notificar a usuarios.


### 4.4 Buenas Prácticas de UX
**Práctica**: Diseña interfaces intuitivas para listings dinámicos.  
**Ejemplo**: Usa formularios modulares adaptados a campos configurables.


---


## 5. Aplicación Práctica en MarketFlex
Ejemplos concretos para implementar estas prácticas en **MarketFlex**:


### 5.1 Organización de Rutas API con SOLID
**Ejemplo**: Controladores separados por recurso.


```tsx
// pages/api/listings.ts
import { ListingController } from "@/controllers/listingController";


export default async function handler(req, res) {
  const controller = new ListingController();
  if (req.method === "POST") {
    await controller.createListing(req, res);
  } else {
    res.status(405).json({ message: "Método no permitido" });
  }
}
```


### 5.2 Función Limpia para Supabase
**Ejemplo**: Encapsula consultas reutilizables.


```tsx
async function getUserTransactions(userId: string) {
  const { data, error } = await supabase
    .from("transactions")
    .select("*")
    .eq("buyer_id", userId)
    .order("created_at", { ascending: false });
  if (error) throw new Error(error.message);
  return data;
}
```


### 5.3 Repository para Listings
**Ejemplo**: Abstrae el acceso a listings.


```tsx
class ListingRepository {
  async getListingsByCategory(category: string) {
    const { data } = await supabase
      .from("listings")
      .select("*")
      .eq("category", category)
      .order("created_at");
    return data;
  }
}
```


---


## Conclusión
La **Guía de Mejores Prácticas** es esencial para desarrollar **MarketFlex** con un código de alta calidad, escalable y fácil de mantener. Siguiendo estas recomendaciones, el equipo sentará las bases para un boilerplate SaaS exitoso.


---